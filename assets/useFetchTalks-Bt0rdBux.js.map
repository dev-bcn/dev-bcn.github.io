{"version":3,"file":"useFetchTalks-Bt0rdBux.js","sources":["../../src/hooks/useFetchTalks.ts"],"sourcesContent":["import axios from \"axios\";\nimport { useQuery } from \"react-query\";\n\nimport type { IGroup, Session } from \"@/types/sessions\";\nimport type { UngroupedSession } from \"@views/Talks/liveView.types\";\nimport type { UseQueryResult } from \"react-query\";\n\nconst URLS = {\n  default: \"https://sessionize.com/api/v2/xhudniix/view/Sessions\",\n  2023: \"https://sessionize.com/api/v2/ttsitynd/view/Sessions\",\n  2024: \"https://sessionize.com/api/v2/teq4asez/view/Sessions\",\n  2025: \"https://sessionize.com/api/v2/xhudniix/view/Sessions\",\n};\n\n/**\n * Determines the URL to use based on the urlOrYear parameter\n * @param urlOrYear - Optional URL or year to use\n * @returns The URL to use\n */\nconst getUrl = (urlOrYear?: string): string => {\n  let url = URLS.default;\n\n  if (urlOrYear) {\n    // If urlOrYear starts with http, it's a URL\n    if (urlOrYear.startsWith(\"http\")) {\n      url = urlOrYear;\n    }\n    // If urlOrYear is a year key in URLS, use that URL\n    else if (urlOrYear in URLS) {\n      url = URLS[urlOrYear as keyof typeof URLS];\n    }\n  }\n\n  return url;\n};\n\n/**\n * Base hook for fetching talks data\n * @param queryKey - The query key to use\n * @param urlOrYear - Optional URL or year to use\n * @param dataTransformer - Function to transform the response data\n * @returns The query result\n */\nconst useFetchTalksBase = <T>(\n  queryKey: string | (string | undefined)[],\n  urlOrYear?: string,\n  dataTransformer: (data: IGroup[]) => T = (data: IGroup[]) =>\n    data as unknown as T,\n): UseQueryResult<T> => {\n  const url = getUrl(urlOrYear);\n\n  return useQuery(\n    queryKey,\n    async () => {\n      const response = await axios.get(url);\n      return dataTransformer(response.data);\n    },\n    {\n      cacheTime: 1800000, // 30 minutes\n      staleTime: 1800000, // 30 minutes\n    },\n  );\n};\n\nexport const useFetchTalks = (urlOrYear?: string): UseQueryResult<IGroup[]> => {\n  return useFetchTalksBase<IGroup[]>(\"api-talks\", urlOrYear);\n};\n\nexport const useFetchTalksById = (\n  id: string,\n  urlOrYear?: string,\n): UseQueryResult<Session> => {\n  return useFetchTalksBase<Session>(\n    [\"talks\", id],\n    urlOrYear,\n    (data: IGroup[]) => {\n      const sessions = data\n        .map((track: IGroup) => track.sessions)\n        .flat(1)\n        .filter(\n          (session: { id: number | string }) => String(session.id) === id,\n        );\n      return sessions[0];\n    },\n  );\n};\n\nexport const useFetchLiveView = (\n  urlOrYear?: string,\n): UseQueryResult<UngroupedSession[]> => {\n  return useFetchTalksBase<Session[]>(\n    \"api-talks\",\n    urlOrYear,\n    (data): UngroupedSession[] =>\n      data.map((track: IGroup) => track.sessions).flat(1),\n  );\n};\n"],"names":["URLS","getUrl","urlOrYear","url","useFetchTalksBase","queryKey","dataTransformer","data","useQuery","response","axios","useFetchTalks","useFetchTalksById","id","track","session","useFetchLiveView"],"mappings":"knBAOA,MAAMA,EAAO,CACX,QAAS,uDACT,KAAM,uDACN,KAAM,uDACN,KAAM,sDACR,EAOMC,EAAUC,GAA+B,CAC7C,IAAIC,EAAMH,EAAK,QAEf,OAAIE,IAEEA,EAAU,WAAW,MAAM,EAC7BC,EAAMD,EAGCA,KAAaF,IACpBG,EAAMH,EAAKE,CAA8B,IAItCC,CACT,EASMC,EAAoB,CACxBC,EACAH,EACAI,EAA0CC,GACxCA,IACoB,CACtB,MAAMJ,EAAMF,EAAOC,CAAS,EAE5B,OAAOM,EACLH,EACA,SAAY,CACV,MAAMI,EAAW,MAAMC,EAAM,IAAIP,CAAG,EACpC,OAAOG,EAAgBG,EAAS,IAAI,CACtC,EACA,CACE,UAAW,KACX,UAAW,IAAA,CACb,CAEJ,EAEaE,EAAiBT,GACrBE,EAA4B,YAAaF,CAAS,EAG9CU,EAAoB,CAC/BC,EACAX,IAEOE,EACL,CAAC,QAASS,CAAE,EACZX,EACCK,GACkBA,EACd,IAAKO,GAAkBA,EAAM,QAAQ,EACrC,KAAK,CAAC,EACN,OACEC,GAAqC,OAAOA,EAAQ,EAAE,IAAMF,CAAA,EAEjD,CAAC,CACnB,EAISG,EACXd,GAEOE,EACL,YACAF,EACCK,GACCA,EAAK,IAAKO,GAAkBA,EAAM,QAAQ,EAAE,KAAK,CAAC,CAAA"}